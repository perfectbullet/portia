{"version":3,"sources":["mutation-summary.js","tree-mirror.js","z_inject_this.js"],"sourcesContent":["// Copyright 2011 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar MutationObserverCtor;\nif (typeof WebKitMutationObserver !== 'undefined')\n    MutationObserverCtor = WebKitMutationObserver;\nelse\n    MutationObserverCtor = MutationObserver;\n\nif (MutationObserverCtor === undefined) {\n    console.error('DOM Mutation Observers are required.');\n    console.error('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');\n    throw Error('DOM Mutation Observers are required');\n}\n\nvar NodeMap = (function () {\n    function NodeMap() {\n        this.nodes = [];\n        this.values = [];\n    }\n    NodeMap.prototype.isIndex = function (s) {\n        return +s === s >>> 0;\n    };\n\n    NodeMap.prototype.nodeId = function (node) {\n        var id = node[NodeMap.ID_PROP];\n        if (!id)\n            id = node[NodeMap.ID_PROP] = NodeMap.nextId_++;\n        return id;\n    };\n\n    NodeMap.prototype.set = function (node, value) {\n        var id = this.nodeId(node);\n        this.nodes[id] = node;\n        this.values[id] = value;\n    };\n\n    NodeMap.prototype.get = function (node) {\n        var id = this.nodeId(node);\n        return this.values[id];\n    };\n\n    NodeMap.prototype.has = function (node) {\n        return this.nodeId(node) in this.nodes;\n    };\n\n    NodeMap.prototype.delete = function (node) {\n        var id = this.nodeId(node);\n        delete this.nodes[id];\n        this.values[id] = undefined;\n    };\n\n    NodeMap.prototype.keys = function () {\n        var nodes = [];\n        for (var id in this.nodes) {\n            if (!this.isIndex(id))\n                continue;\n            nodes.push(this.nodes[id]);\n        }\n\n        return nodes;\n    };\n    NodeMap.ID_PROP = '__mutation_summary_node_map_id__';\n    NodeMap.nextId_ = 1;\n    return NodeMap;\n})();\n\nfunction NodeIdMap(){\n    NodeMap.call(this);\n    this.byId = {}; // Id -> Node\n}\nNodeIdMap.prototype = new NodeMap();\nNodeIdMap.prototype.delete = function(node) {\n    var id = this.get(node);\n    if(id){\n        NodeMap.prototype.delete.call(this, node);\n        delete this.byId[id];\n    }\n};\nNodeIdMap.prototype.set = function(node, id) {\n    NodeMap.prototype.set.call(this, node, id);\n    this.byId[id] = node;\n};\n/**\n*  var reachableMatchableProduct = [\n*  //  STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED\n*    [ STAYED_OUT,  STAYED_OUT,  STAYED_OUT,  STAYED_OUT ], // STAYED_OUT\n*    [ STAYED_OUT,  ENTERED,     ENTERED,     STAYED_OUT ], // ENTERED\n*    [ STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED     ], // STAYED_IN\n*    [ STAYED_OUT,  STAYED_OUT,  EXITED,      EXITED     ]  // EXITED\n*  ];\n*/\nvar Movement;\n(function (Movement) {\n    Movement[Movement[\"STAYED_OUT\"] = 0] = \"STAYED_OUT\";\n    Movement[Movement[\"ENTERED\"] = 1] = \"ENTERED\";\n    Movement[Movement[\"STAYED_IN\"] = 2] = \"STAYED_IN\";\n    Movement[Movement[\"REPARENTED\"] = 3] = \"REPARENTED\";\n    Movement[Movement[\"REORDERED\"] = 4] = \"REORDERED\";\n    Movement[Movement[\"EXITED\"] = 5] = \"EXITED\";\n})(Movement || (Movement = {}));\n\nfunction enteredOrExited(changeType) {\n    return changeType === 1 /* ENTERED */ || changeType === 5 /* EXITED */;\n}\n\nvar NodeChange = (function () {\n    function NodeChange(node, childList, attributes, characterData, oldParentNode, added, attributeOldValues, characterDataOldValue) {\n        if (typeof childList === \"undefined\") { childList = false; }\n        if (typeof attributes === \"undefined\") { attributes = false; }\n        if (typeof characterData === \"undefined\") { characterData = false; }\n        if (typeof oldParentNode === \"undefined\") { oldParentNode = null; }\n        if (typeof added === \"undefined\") { added = false; }\n        if (typeof attributeOldValues === \"undefined\") { attributeOldValues = null; }\n        if (typeof characterDataOldValue === \"undefined\") { characterDataOldValue = null; }\n        this.node = node;\n        this.childList = childList;\n        this.attributes = attributes;\n        this.characterData = characterData;\n        this.oldParentNode = oldParentNode;\n        this.added = added;\n        this.attributeOldValues = attributeOldValues;\n        this.characterDataOldValue = characterDataOldValue;\n        this.isCaseInsensitive = this.node.nodeType === Node.ELEMENT_NODE && this.node instanceof HTMLElement && this.node.ownerDocument instanceof HTMLDocument;\n    }\n    NodeChange.prototype.getAttributeOldValue = function (name) {\n        if (!this.attributeOldValues)\n            return undefined;\n        if (this.isCaseInsensitive)\n            name = name.toLowerCase();\n        return this.attributeOldValues[name];\n    };\n\n    NodeChange.prototype.getAttributeNamesMutated = function () {\n        var names = [];\n        if (!this.attributeOldValues)\n            return names;\n        for (var name in this.attributeOldValues) {\n            names.push(name);\n        }\n        return names;\n    };\n\n    NodeChange.prototype.attributeMutated = function (name, oldValue) {\n        this.attributes = true;\n        this.attributeOldValues = this.attributeOldValues || {};\n\n        if (name in this.attributeOldValues)\n            return;\n\n        this.attributeOldValues[name] = oldValue;\n    };\n\n    NodeChange.prototype.characterDataMutated = function (oldValue) {\n        if (this.characterData)\n            return;\n        this.characterData = true;\n        this.characterDataOldValue = oldValue;\n    };\n\n    // Note: is it possible to receive a removal followed by a removal. This\n    // can occur if the removed node is added to an non-observed node, that\n    // node is added to the observed area, and then the node removed from\n    // it.\n    NodeChange.prototype.removedFromParent = function (parent) {\n        this.childList = true;\n        if (this.added || this.oldParentNode)\n            this.added = false;\n        else\n            this.oldParentNode = parent;\n    };\n\n    NodeChange.prototype.insertedIntoParent = function () {\n        this.childList = true;\n        this.added = true;\n    };\n\n    // An node's oldParent is\n    //   -its present parent, if its parentNode was not changed.\n    //   -null if the first thing that happened to it was an add.\n    //   -the node it was removed from if the first thing that happened to it\n    //      was a remove.\n    NodeChange.prototype.getOldParent = function () {\n        if (this.childList) {\n            if (this.oldParentNode)\n                return this.oldParentNode;\n            if (this.added)\n                return null;\n        }\n\n        return this.node.parentNode;\n    };\n    return NodeChange;\n})();\n\nvar ChildListChange = (function () {\n    function ChildListChange() {\n        this.added = new NodeMap();\n        this.removed = new NodeMap();\n        this.maybeMoved = new NodeMap();\n        this.oldPrevious = new NodeMap();\n        this.moved = undefined;\n    }\n    return ChildListChange;\n})();\n\nvar TreeChanges = (function (_super) {\n    __extends(TreeChanges, _super);\n    function TreeChanges(rootNode, mutations) {\n        _super.call(this);\n\n        this.rootNode = rootNode;\n        this.reachableCache = undefined;\n        this.wasReachableCache = undefined;\n        this.anyParentsChanged = false;\n        this.anyAttributesChanged = false;\n        this.anyCharacterDataChanged = false;\n\n        for (var m = 0; m < mutations.length; m++) {\n            var mutation = mutations[m];\n            switch (mutation.type) {\n                case 'childList':\n                    this.anyParentsChanged = true;\n                    for (var i = 0; i < mutation.removedNodes.length; i++) {\n                        var node = mutation.removedNodes[i];\n                        this.getChange(node).removedFromParent(mutation.target);\n                    }\n                    for (var i = 0; i < mutation.addedNodes.length; i++) {\n                        var node = mutation.addedNodes[i];\n                        this.getChange(node).insertedIntoParent();\n                    }\n                    break;\n\n                case 'attributes':\n                    this.anyAttributesChanged = true;\n                    var change = this.getChange(mutation.target);\n                    change.attributeMutated(mutation.attributeName, mutation.oldValue);\n                    break;\n\n                case 'characterData':\n                    this.anyCharacterDataChanged = true;\n                    var change = this.getChange(mutation.target);\n                    change.characterDataMutated(mutation.oldValue);\n                    break;\n            }\n        }\n    }\n    TreeChanges.prototype.getChange = function (node) {\n        var change = this.get(node);\n        if (!change) {\n            change = new NodeChange(node);\n            this.set(node, change);\n        }\n        return change;\n    };\n\n    TreeChanges.prototype.getOldParent = function (node) {\n        var change = this.get(node);\n        return change ? change.getOldParent() : node.parentNode;\n    };\n\n    TreeChanges.prototype.getIsReachable = function (node) {\n        if (node === this.rootNode)\n            return true;\n        if (!node)\n            return false;\n\n        this.reachableCache = this.reachableCache || new NodeMap();\n        var isReachable = this.reachableCache.get(node);\n        if (isReachable === undefined) {\n            isReachable = this.getIsReachable(node.parentNode);\n            this.reachableCache.set(node, isReachable);\n        }\n        return isReachable;\n    };\n\n    // A node wasReachable if its oldParent wasReachable.\n    TreeChanges.prototype.getWasReachable = function (node) {\n        if (node === this.rootNode)\n            return true;\n        if (!node)\n            return false;\n\n        this.wasReachableCache = this.wasReachableCache || new NodeMap();\n        var wasReachable = this.wasReachableCache.get(node);\n        if (wasReachable === undefined) {\n            wasReachable = this.getWasReachable(this.getOldParent(node));\n            this.wasReachableCache.set(node, wasReachable);\n        }\n        return wasReachable;\n    };\n\n    TreeChanges.prototype.reachabilityChange = function (node) {\n        if (this.getIsReachable(node)) {\n            return this.getWasReachable(node) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;\n        }\n\n        return this.getWasReachable(node) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;\n    };\n    return TreeChanges;\n})(NodeMap);\n\nvar MutationProjection = (function () {\n    // TOOD(any)\n    function MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {\n        this.rootNode = rootNode;\n        this.mutations = mutations;\n        this.selectors = selectors;\n        this.calcReordered = calcReordered;\n        this.calcOldPreviousSibling = calcOldPreviousSibling;\n        this.treeChanges = new TreeChanges(rootNode, mutations);\n        this.entered = [];\n        this.exited = [];\n        this.stayedIn = new NodeMap();\n        this.visited = new NodeMap();\n        this.childListChangeMap = undefined;\n        this.characterDataOnly = undefined;\n        this.matchCache = undefined;\n\n        this.processMutations();\n    }\n    MutationProjection.prototype.processMutations = function () {\n        if (!this.treeChanges.anyParentsChanged && !this.treeChanges.anyAttributesChanged)\n            return;\n\n        var changedNodes = this.treeChanges.keys();\n        for (var i = 0; i < changedNodes.length; i++) {\n            this.visitNode(changedNodes[i], undefined);\n        }\n    };\n\n    MutationProjection.prototype.visitNode = function (node, parentReachable) {\n        if (this.visited.has(node))\n            return;\n\n        this.visited.set(node, true);\n\n        var change = this.treeChanges.get(node);\n        var reachable = parentReachable;\n\n        // node inherits its parent's reachability change unless\n        // its parentNode was mutated.\n        if ((change && change.childList) || reachable == undefined)\n            reachable = this.treeChanges.reachabilityChange(node);\n\n        if (reachable === 0 /* STAYED_OUT */)\n            return;\n\n        // Cache match results for sub-patterns.\n        this.matchabilityChange(node);\n\n        if (reachable === 1 /* ENTERED */) {\n            this.entered.push(node);\n        } else if (reachable === 5 /* EXITED */) {\n            this.exited.push(node);\n            this.ensureHasOldPreviousSiblingIfNeeded(node);\n        } else if (reachable === 2 /* STAYED_IN */) {\n            var movement = 2 /* STAYED_IN */;\n\n            if (change && change.childList) {\n                if (change.oldParentNode !== node.parentNode) {\n                    movement = 3 /* REPARENTED */;\n                    this.ensureHasOldPreviousSiblingIfNeeded(node);\n                } else if (this.calcReordered && this.wasReordered(node)) {\n                    movement = 4 /* REORDERED */;\n                }\n            }\n\n            this.stayedIn.set(node, movement);\n        }\n\n        if (reachable === 2 /* STAYED_IN */)\n            return;\n\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n            this.visitNode(child, reachable);\n        }\n    };\n\n    MutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {\n        if (!this.calcOldPreviousSibling)\n            return;\n\n        this.processChildlistChanges();\n\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change) {\n            change = new ChildListChange();\n            this.childListChangeMap.set(parentNode, change);\n        }\n\n        if (!change.oldPrevious.has(node)) {\n            change.oldPrevious.set(node, node.previousSibling);\n        }\n    };\n\n    MutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {\n        this.selectors = selectors;\n        this.characterDataOnly = characterDataOnly;\n\n        for (var i = 0; i < this.entered.length; i++) {\n            var node = this.entered[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === 1 /* ENTERED */ || matchable === 2 /* STAYED_IN */)\n                summary.added.push(node);\n        }\n\n        var stayedInNodes = this.stayedIn.keys();\n        for (var i = 0; i < stayedInNodes.length; i++) {\n            var node = stayedInNodes[i];\n            var matchable = this.matchabilityChange(node);\n\n            if (matchable === 1 /* ENTERED */) {\n                summary.added.push(node);\n            } else if (matchable === 5 /* EXITED */) {\n                summary.removed.push(node);\n            } else if (matchable === 2 /* STAYED_IN */ && (summary.reparented || summary.reordered)) {\n                var movement = this.stayedIn.get(node);\n                if (summary.reparented && movement === 3 /* REPARENTED */)\n                    summary.reparented.push(node);\n                else if (summary.reordered && movement === 4 /* REORDERED */)\n                    summary.reordered.push(node);\n            }\n        }\n\n        for (var i = 0; i < this.exited.length; i++) {\n            var node = this.exited[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === 5 /* EXITED */ || matchable === 2 /* STAYED_IN */)\n                summary.removed.push(node);\n        }\n    };\n\n    MutationProjection.prototype.getOldParentNode = function (node) {\n        var change = this.treeChanges.get(node);\n        if (change && change.childList)\n            return change.oldParentNode ? change.oldParentNode : null;\n\n        var reachabilityChange = this.treeChanges.reachabilityChange(node);\n        if (reachabilityChange === 0 /* STAYED_OUT */ || reachabilityChange === 1 /* ENTERED */)\n            throw Error('getOldParentNode requested on invalid node.');\n\n        return node.parentNode;\n    };\n\n    MutationProjection.prototype.getOldPreviousSibling = function (node) {\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change)\n            throw Error('getOldPreviousSibling requested on invalid node.');\n\n        return change.oldPrevious.get(node);\n    };\n\n    MutationProjection.prototype.getOldAttribute = function (element, attrName) {\n        var change = this.treeChanges.get(element);\n        if (!change || !change.attributes)\n            throw Error('getOldAttribute requested on invalid node.');\n\n        var value = change.getAttributeOldValue(attrName);\n        if (value === undefined)\n            throw Error('getOldAttribute requested for unchanged attribute name.');\n\n        return value;\n    };\n\n    MutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {\n        if (!this.treeChanges.anyAttributesChanged)\n            return {};\n\n        var attributeFilter;\n        var caseInsensitiveFilter;\n        if (includeAttributes) {\n            attributeFilter = {};\n            caseInsensitiveFilter = {};\n            for (var i = 0; i < includeAttributes.length; i++) {\n                var attrName = includeAttributes[i];\n                attributeFilter[attrName] = true;\n                caseInsensitiveFilter[attrName.toLowerCase()] = attrName;\n            }\n        }\n\n        var result = {};\n        var nodes = this.treeChanges.keys();\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n\n            var change = this.treeChanges.get(node);\n            if (!change.attributes)\n                continue;\n\n            if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(node) || 2 /* STAYED_IN */ !== this.matchabilityChange(node)) {\n                continue;\n            }\n\n            var element = node;\n            var changedAttrNames = change.getAttributeNamesMutated();\n            for (var j = 0; j < changedAttrNames.length; j++) {\n                var attrName = changedAttrNames[j];\n\n                if (attributeFilter && !attributeFilter[attrName] && !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {\n                    continue;\n                }\n\n                var oldValue = change.getAttributeOldValue(attrName);\n                if (oldValue === element.getAttribute(attrName))\n                    continue;\n\n                if (caseInsensitiveFilter && change.isCaseInsensitive)\n                    attrName = caseInsensitiveFilter[attrName];\n\n                result[attrName] = result[attrName] || [];\n                result[attrName].push(element);\n            }\n        }\n\n        return result;\n    };\n\n    MutationProjection.prototype.getOldCharacterData = function (node) {\n        var change = this.treeChanges.get(node);\n        if (!change || !change.characterData)\n            throw Error('getOldCharacterData requested on invalid node.');\n\n        return change.characterDataOldValue;\n    };\n\n    MutationProjection.prototype.getCharacterDataChanged = function () {\n        if (!this.treeChanges.anyCharacterDataChanged)\n            return [];\n\n        var nodes = this.treeChanges.keys();\n        var result = [];\n        for (var i = 0; i < nodes.length; i++) {\n            var target = nodes[i];\n            if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(target))\n                continue;\n\n            var change = this.treeChanges.get(target);\n            if (!change.characterData || target.textContent == change.characterDataOldValue)\n                continue;\n\n            result.push(target);\n        }\n\n        return result;\n    };\n\n    MutationProjection.prototype.computeMatchabilityChange = function (selector, el) {\n        if (!this.matchCache)\n            this.matchCache = [];\n        if (!this.matchCache[selector.uid])\n            this.matchCache[selector.uid] = new NodeMap();\n\n        var cache = this.matchCache[selector.uid];\n        var result = cache.get(el);\n        if (result === undefined) {\n            result = selector.matchabilityChange(el, this.treeChanges.get(el));\n            cache.set(el, result);\n        }\n        return result;\n    };\n\n    MutationProjection.prototype.matchabilityChange = function (node) {\n        var _this = this;\n        // TODO(rafaelw): Include PI, CDATA?\n        // Only include text nodes.\n        if (this.characterDataOnly) {\n            switch (node.nodeType) {\n                case Node.COMMENT_NODE:\n                case Node.TEXT_NODE:\n                    return 2 /* STAYED_IN */;\n                default:\n                    return 0 /* STAYED_OUT */;\n            }\n        }\n\n        // No element filter. Include all nodes.\n        if (!this.selectors)\n            return 2 /* STAYED_IN */;\n\n        // Element filter. Exclude non-elements.\n        if (node.nodeType !== Node.ELEMENT_NODE)\n            return 0 /* STAYED_OUT */;\n\n        var el = node;\n\n        var matchChanges = this.selectors.map(function (selector) {\n            return _this.computeMatchabilityChange(selector, el);\n        });\n\n        var accum = 0 /* STAYED_OUT */;\n        var i = 0;\n\n        while (accum !== 2 /* STAYED_IN */ && i < matchChanges.length) {\n            switch (matchChanges[i]) {\n                case 2 /* STAYED_IN */:\n                    accum = 2 /* STAYED_IN */;\n                    break;\n                case 1 /* ENTERED */:\n                    if (accum === 5 /* EXITED */)\n                        accum = 2 /* STAYED_IN */;\n                    else\n                        accum = 1 /* ENTERED */;\n                    break;\n                case 5 /* EXITED */:\n                    if (accum === 1 /* ENTERED */)\n                        accum = 2 /* STAYED_IN */;\n                    else\n                        accum = 5 /* EXITED */;\n                    break;\n            }\n\n            i++;\n        }\n\n        return accum;\n    };\n\n    MutationProjection.prototype.getChildlistChange = function (el) {\n        var change = this.childListChangeMap.get(el);\n        if (!change) {\n            change = new ChildListChange();\n            this.childListChangeMap.set(el, change);\n        }\n\n        return change;\n    };\n\n    MutationProjection.prototype.processChildlistChanges = function () {\n        if (this.childListChangeMap)\n            return;\n\n        this.childListChangeMap = new NodeMap();\n\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.type != 'childList')\n                continue;\n\n            if (this.treeChanges.reachabilityChange(mutation.target) !== 2 /* STAYED_IN */ && !this.calcOldPreviousSibling)\n                continue;\n\n            var change = this.getChildlistChange(mutation.target);\n\n            var oldPrevious = mutation.previousSibling;\n\n            function recordOldPrevious(node, previous) {\n                if (!node || change.oldPrevious.has(node) || change.added.has(node) || change.maybeMoved.has(node))\n                    return;\n\n                if (previous && (change.added.has(previous) || change.maybeMoved.has(previous)))\n                    return;\n\n                change.oldPrevious.set(node, previous);\n            }\n\n            for (var j = 0; j < mutation.removedNodes.length; j++) {\n                var node = mutation.removedNodes[j];\n                recordOldPrevious(node, oldPrevious);\n\n                if (change.added.has(node)) {\n                    change.added.delete(node);\n                } else {\n                    change.removed.set(node, true);\n                    change.maybeMoved.delete(node);\n                }\n\n                oldPrevious = node;\n            }\n\n            recordOldPrevious(mutation.nextSibling, oldPrevious);\n\n            for (var j = 0; j < mutation.addedNodes.length; j++) {\n                var node = mutation.addedNodes[j];\n                if (change.removed.has(node)) {\n                    change.removed.delete(node);\n                    change.maybeMoved.set(node, true);\n                } else {\n                    change.added.set(node, true);\n                }\n            }\n        }\n    };\n\n    MutationProjection.prototype.wasReordered = function (node) {\n        if (!this.treeChanges.anyParentsChanged)\n            return false;\n\n        this.processChildlistChanges();\n\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change)\n            return false;\n\n        if (change.moved)\n            return change.moved.get(node);\n\n        change.moved = new NodeMap();\n        var pendingMoveDecision = new NodeMap();\n\n        function isMoved(node) {\n            if (!node)\n                return false;\n            if (!change.maybeMoved.has(node))\n                return false;\n\n            var didMove = change.moved.get(node);\n            if (didMove !== undefined)\n                return didMove;\n\n            if (pendingMoveDecision.has(node)) {\n                didMove = true;\n            } else {\n                pendingMoveDecision.set(node, true);\n                didMove = getPrevious(node) !== getOldPrevious(node);\n            }\n\n            if (pendingMoveDecision.has(node)) {\n                pendingMoveDecision.delete(node);\n                change.moved.set(node, didMove);\n            } else {\n                didMove = change.moved.get(node);\n            }\n\n            return didMove;\n        }\n\n        var oldPreviousCache = new NodeMap();\n        function getOldPrevious(node) {\n            var oldPrevious = oldPreviousCache.get(node);\n            if (oldPrevious !== undefined)\n                return oldPrevious;\n\n            oldPrevious = change.oldPrevious.get(node);\n            while (oldPrevious && (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {\n                oldPrevious = getOldPrevious(oldPrevious);\n            }\n\n            if (oldPrevious === undefined)\n                oldPrevious = node.previousSibling;\n            oldPreviousCache.set(node, oldPrevious);\n\n            return oldPrevious;\n        }\n\n        var previousCache = new NodeMap();\n        function getPrevious(node) {\n            if (previousCache.has(node))\n                return previousCache.get(node);\n\n            var previous = node.previousSibling;\n            while (previous && (change.added.has(previous) || isMoved(previous)))\n                previous = previous.previousSibling;\n\n            previousCache.set(node, previous);\n            return previous;\n        }\n\n        change.maybeMoved.keys().forEach(isMoved);\n        return change.moved.get(node);\n    };\n    return MutationProjection;\n})();\n\nvar Summary = (function () {\n    function Summary(projection, query) {\n        var _this = this;\n        this.projection = projection;\n        this.added = [];\n        this.removed = [];\n        this.reparented = query.all || query.element ? [] : undefined;\n        this.reordered = query.all ? [] : undefined;\n\n        projection.getChanged(this, query.elementFilter, query.characterData);\n\n        if (query.all || query.attribute || query.attributeList) {\n            var filter = query.attribute ? [query.attribute] : query.attributeList;\n            var attributeChanged = projection.attributeChangedNodes(filter);\n\n            if (query.attribute) {\n                this.valueChanged = attributeChanged[query.attribute] || [];\n            } else {\n                this.attributeChanged = attributeChanged;\n                if (query.attributeList) {\n                    query.attributeList.forEach(function (attrName) {\n                        if (!_this.attributeChanged.hasOwnProperty(attrName))\n                            _this.attributeChanged[attrName] = [];\n                    });\n                }\n            }\n        }\n\n        if (query.all || query.characterData) {\n            var characterDataChanged = projection.getCharacterDataChanged();\n\n            if (query.characterData)\n                this.valueChanged = characterDataChanged;\n            else\n                this.characterDataChanged = characterDataChanged;\n        }\n\n        if (this.reordered)\n            this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);\n    }\n    Summary.prototype.getOldParentNode = function (node) {\n        return this.projection.getOldParentNode(node);\n    };\n\n    Summary.prototype.getOldAttribute = function (node, name) {\n        return this.projection.getOldAttribute(node, name);\n    };\n\n    Summary.prototype.getOldCharacterData = function (node) {\n        return this.projection.getOldCharacterData(node);\n    };\n\n    Summary.prototype.getOldPreviousSibling = function (node) {\n        return this.projection.getOldPreviousSibling(node);\n    };\n    return Summary;\n})();\n\n// TODO(rafaelw): Allow ':' and '.' as valid name characters.\nvar validNameInitialChar = /[a-zA-Z_]+/;\nvar validNameNonInitialChar = /[a-zA-Z0-9_\\-]+/;\n\n// TODO(rafaelw): Consider allowing backslash in the attrValue.\n// TODO(rafaelw): There's got a to be way to represent this state machine\n// more compactly???\nfunction escapeQuotes(value) {\n    return '\"' + value.replace(/\"/, '\\\\\\\"') + '\"';\n}\n\nvar Qualifier = (function () {\n    function Qualifier() {\n    }\n    Qualifier.prototype.matches = function (oldValue) {\n        if (oldValue === null)\n            return false;\n\n        if (this.attrValue === undefined)\n            return true;\n\n        if (!this.contains)\n            return this.attrValue == oldValue;\n\n        var tokens = oldValue.split(' ');\n        for (var i = 0; i < tokens.length; i++) {\n            if (this.attrValue === tokens[i])\n                return true;\n        }\n\n        return false;\n    };\n\n    Qualifier.prototype.toString = function () {\n        if (this.attrName === 'class' && this.contains)\n            return '.' + this.attrValue;\n\n        if (this.attrName === 'id' && !this.contains)\n            return '#' + this.attrValue;\n\n        if (this.contains)\n            return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';\n\n        if ('attrValue' in this)\n            return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';\n\n        return '[' + this.attrName + ']';\n    };\n    return Qualifier;\n})();\n\nvar Selector = (function () {\n    function Selector() {\n        this.uid = Selector.nextUid++;\n        this.qualifiers = [];\n    }\n    Object.defineProperty(Selector.prototype, \"caseInsensitiveTagName\", {\n        get: function () {\n            return this.tagName.toUpperCase();\n        },\n        enumerable: true,\n        configurable: true\n    });\n\n    Object.defineProperty(Selector.prototype, \"selectorString\", {\n        get: function () {\n            return this.tagName + this.qualifiers.join('');\n        },\n        enumerable: true,\n        configurable: true\n    });\n\n    Selector.prototype.isMatching = function (el) {\n        return el[Selector.matchesSelector](this.selectorString);\n    };\n\n    Selector.prototype.wasMatching = function (el, change, isMatching) {\n        if (!change || !change.attributes)\n            return isMatching;\n\n        var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;\n        if (tagName !== '*' && tagName !== el.tagName)\n            return false;\n\n        var attributeOldValues = [];\n        var anyChanged = false;\n        for (var i = 0; i < this.qualifiers.length; i++) {\n            var qualifier = this.qualifiers[i];\n            var oldValue = change.getAttributeOldValue(qualifier.attrName);\n            attributeOldValues.push(oldValue);\n            anyChanged = anyChanged || (oldValue !== undefined);\n        }\n\n        if (!anyChanged)\n            return isMatching;\n\n        for (var i = 0; i < this.qualifiers.length; i++) {\n            var qualifier = this.qualifiers[i];\n            var oldValue = attributeOldValues[i];\n            if (oldValue === undefined)\n                oldValue = el.getAttribute(qualifier.attrName);\n            if (!qualifier.matches(oldValue))\n                return false;\n        }\n\n        return true;\n    };\n\n    Selector.prototype.matchabilityChange = function (el, change) {\n        var isMatching = this.isMatching(el);\n        if (isMatching)\n            return this.wasMatching(el, change, isMatching) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;\n        else\n            return this.wasMatching(el, change, isMatching) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;\n    };\n\n    Selector.parseSelectors = function (input) {\n        var selectors = [];\n        var currentSelector;\n        var currentQualifier;\n\n        function newSelector() {\n            if (currentSelector) {\n                if (currentQualifier) {\n                    currentSelector.qualifiers.push(currentQualifier);\n                    currentQualifier = undefined;\n                }\n\n                selectors.push(currentSelector);\n            }\n            currentSelector = new Selector();\n        }\n\n        function newQualifier() {\n            if (currentQualifier)\n                currentSelector.qualifiers.push(currentQualifier);\n\n            currentQualifier = new Qualifier();\n        }\n\n        var WHITESPACE = /\\s/;\n        var valueQuoteChar;\n        var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';\n\n        var SELECTOR = 1;\n        var TAG_NAME = 2;\n        var QUALIFIER = 3;\n        var QUALIFIER_NAME_FIRST_CHAR = 4;\n        var QUALIFIER_NAME = 5;\n        var ATTR_NAME_FIRST_CHAR = 6;\n        var ATTR_NAME = 7;\n        var EQUIV_OR_ATTR_QUAL_END = 8;\n        var EQUAL = 9;\n        var ATTR_QUAL_END = 10;\n        var VALUE_FIRST_CHAR = 11;\n        var VALUE = 12;\n        var QUOTED_VALUE = 13;\n        var SELECTOR_SEPARATOR = 14;\n\n        var state = SELECTOR;\n        var i = 0;\n        while (i < input.length) {\n            var c = input[i++];\n\n            switch (state) {\n                case SELECTOR:\n                    if (c.match(validNameInitialChar)) {\n                        newSelector();\n                        currentSelector.tagName = c;\n                        state = TAG_NAME;\n                        break;\n                    }\n\n                    if (c == '*') {\n                        newSelector();\n                        currentSelector.tagName = '*';\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    if (c == '.') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case TAG_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentSelector.tagName += c;\n                        break;\n                    }\n\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case QUALIFIER:\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case QUALIFIER_NAME_FIRST_CHAR:\n                    if (c.match(validNameInitialChar)) {\n                        currentQualifier.attrValue = c;\n                        state = QUALIFIER_NAME;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case QUALIFIER_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentQualifier.attrValue += c;\n                        break;\n                    }\n\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case ATTR_NAME_FIRST_CHAR:\n                    if (c.match(validNameInitialChar)) {\n                        currentQualifier.attrName = c;\n                        state = ATTR_NAME;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case ATTR_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentQualifier.attrName += c;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE)) {\n                        state = EQUIV_OR_ATTR_QUAL_END;\n                        break;\n                    }\n\n                    if (c == '~') {\n                        currentQualifier.contains = true;\n                        state = EQUAL;\n                        break;\n                    }\n\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case EQUIV_OR_ATTR_QUAL_END:\n                    if (c == '~') {\n                        currentQualifier.contains = true;\n                        state = EQUAL;\n                        break;\n                    }\n\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case EQUAL:\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n\n                case ATTR_QUAL_END:\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    throw Error(SYNTAX_ERROR);\n\n                case VALUE_FIRST_CHAR:\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    if (c == '\"' || c == \"'\") {\n                        valueQuoteChar = c;\n                        state = QUOTED_VALUE;\n                        break;\n                    }\n\n                    currentQualifier.attrValue += c;\n                    state = VALUE;\n                    break;\n\n                case VALUE:\n                    if (c.match(WHITESPACE)) {\n                        state = ATTR_QUAL_END;\n                        break;\n                    }\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n                    if (c == \"'\" || c == '\"')\n                        throw Error(SYNTAX_ERROR);\n\n                    currentQualifier.attrValue += c;\n                    break;\n\n                case QUOTED_VALUE:\n                    if (c == valueQuoteChar) {\n                        state = ATTR_QUAL_END;\n                        break;\n                    }\n\n                    currentQualifier.attrValue += c;\n                    break;\n\n                case SELECTOR_SEPARATOR:\n                    if (c.match(WHITESPACE))\n                        break;\n\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n\n                    throw Error(SYNTAX_ERROR);\n            }\n        }\n\n        switch (state) {\n            case SELECTOR:\n            case TAG_NAME:\n            case QUALIFIER:\n            case QUALIFIER_NAME:\n            case SELECTOR_SEPARATOR:\n                // Valid end states.\n                newSelector();\n                break;\n            default:\n                throw Error(SYNTAX_ERROR);\n        }\n\n        if (!selectors.length)\n            throw Error(SYNTAX_ERROR);\n\n        return selectors;\n    };\n    Selector.nextUid = 1;\n    Selector.matchesSelector = (function () {\n        var element = document.createElement('div');\n        if (typeof element['webkitMatchesSelector'] === 'function')\n            return 'webkitMatchesSelector';\n        if (typeof element['mozMatchesSelector'] === 'function')\n            return 'mozMatchesSelector';\n        if (typeof element['msMatchesSelector'] === 'function')\n            return 'msMatchesSelector';\n\n        return 'matchesSelector';\n    })();\n    return Selector;\n})();\n\nvar attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\\-:\\.]*)$/;\n\nfunction validateAttribute(attribute) {\n    if (typeof attribute != 'string')\n        throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    attribute = attribute.trim();\n\n    if (!attribute)\n        throw Error('Invalid request opion. attribute must be a non-zero length string.');\n\n    if (!attribute.match(attributeFilterPattern))\n        throw Error('Invalid request option. invalid attribute name: ' + attribute);\n\n    return attribute;\n}\n\nfunction validateElementAttributes(attribs) {\n    if (!attribs.trim().length)\n        throw Error('Invalid request option: elementAttributes must contain at least one attribute.');\n\n    var lowerAttributes = {};\n    var attributes = {};\n\n    var tokens = attribs.split(/\\s+/);\n    for (var i = 0; i < tokens.length; i++) {\n        var name = tokens[i];\n        if (!name)\n            continue;\n\n        var name = validateAttribute(name);\n        var nameLower = name.toLowerCase();\n        if (lowerAttributes[nameLower])\n            throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');\n\n        attributes[name] = true;\n        lowerAttributes[nameLower] = true;\n    }\n\n    return Object.keys(attributes);\n}\n\nfunction elementFilterAttributes(selectors) {\n    var attributes = {};\n\n    selectors.forEach(function (selector) {\n        selector.qualifiers.forEach(function (qualifier) {\n            attributes[qualifier.attrName] = true;\n        });\n    });\n\n    return Object.keys(attributes);\n}\n\nvar MutationSummary = (function () {\n    function MutationSummary(opts) {\n        var _this = this;\n        this.connected = false;\n        this.options = MutationSummary.validateOptions(opts);\n        this.observerOptions = MutationSummary.createObserverOptions(this.options.queries);\n        this.root = this.options.rootNode;\n        this.callback = this.options.callback;\n\n        this.elementFilter = Array.prototype.concat.apply([], this.options.queries.map(function (query) {\n            return query.elementFilter ? query.elementFilter : [];\n        }));\n        if (!this.elementFilter.length)\n            this.elementFilter = undefined;\n\n        this.calcReordered = this.options.queries.some(function (query) {\n            return query.all;\n        });\n\n        this.queryValidators = []; // TODO(rafaelw): Shouldn't always define this.\n        if (MutationSummary.createQueryValidator) {\n            this.queryValidators = this.options.queries.map(function (query) {\n                return MutationSummary.createQueryValidator(_this.root, query);\n            });\n        }\n\n        this.observer = new MutationObserverCtor(function (mutations) {\n            _this.observerCallback(mutations);\n        });\n\n        this.reconnect();\n    }\n    MutationSummary.createObserverOptions = function (queries) {\n        var observerOptions = {\n            childList: true,\n            subtree: true\n        };\n\n        var attributeFilter;\n        function observeAttributes(attributes) {\n            if (observerOptions.attributes && !attributeFilter)\n                return;\n\n            observerOptions.attributes = true;\n            observerOptions.attributeOldValue = true;\n\n            if (!attributes) {\n                // observe all.\n                attributeFilter = undefined;\n                return;\n            }\n\n            // add to observed.\n            attributeFilter = attributeFilter || {};\n            attributes.forEach(function (attribute) {\n                attributeFilter[attribute] = true;\n                attributeFilter[attribute.toLowerCase()] = true;\n            });\n        }\n\n        queries.forEach(function (query) {\n            if (query.characterData) {\n                observerOptions.characterData = true;\n                observerOptions.characterDataOldValue = true;\n                return;\n            }\n\n            if (query.all) {\n                observeAttributes();\n                observerOptions.characterData = true;\n                observerOptions.characterDataOldValue = true;\n                return;\n            }\n\n            if (query.attribute) {\n                observeAttributes([query.attribute.trim()]);\n                return;\n            }\n\n            var attributes = elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);\n            if (attributes.length)\n                observeAttributes(attributes);\n        });\n\n        if (attributeFilter)\n            observerOptions.attributeFilter = Object.keys(attributeFilter);\n\n        return observerOptions;\n    };\n\n    MutationSummary.validateOptions = function (options) {\n        for (var prop in options) {\n            if (!(prop in MutationSummary.optionKeys))\n                throw Error('Invalid option: ' + prop);\n        }\n\n        if (typeof options.callback !== 'function')\n            throw Error('Invalid options: callback is required and must be a function');\n\n        if (!options.queries || !options.queries.length)\n            throw Error('Invalid options: queries must contain at least one query request object.');\n\n        var opts = {\n            callback: options.callback,\n            rootNode: options.rootNode || document,\n            observeOwnChanges: !!options.observeOwnChanges,\n            oldPreviousSibling: !!options.oldPreviousSibling,\n            queries: []\n        };\n\n        for (var i = 0; i < options.queries.length; i++) {\n            var request = options.queries[i];\n\n            // all\n            if (request.all) {\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. all has no options.');\n\n                opts.queries.push({ all: true });\n                continue;\n            }\n\n            // attribute\n            if ('attribute' in request) {\n                var query = {\n                    attribute: validateAttribute(request.attribute)\n                };\n\n                query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');\n\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. attribute has no options.');\n\n                opts.queries.push(query);\n                continue;\n            }\n\n            // element\n            if ('element' in request) {\n                var requestOptionCount = Object.keys(request).length;\n                var query = {\n                    element: request.element,\n                    elementFilter: Selector.parseSelectors(request.element)\n                };\n\n                if (request.hasOwnProperty('elementAttributes')) {\n                    query.attributeList = validateElementAttributes(request.elementAttributes);\n                    requestOptionCount--;\n                }\n\n                if (requestOptionCount > 1)\n                    throw Error('Invalid request option. element only allows elementAttributes option.');\n\n                opts.queries.push(query);\n                continue;\n            }\n\n            // characterData\n            if (request.characterData) {\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. characterData has no options.');\n\n                opts.queries.push({ characterData: true });\n                continue;\n            }\n\n            throw Error('Invalid request option. Unknown query request.');\n        }\n\n        return opts;\n    };\n\n    MutationSummary.prototype.createSummaries = function (mutations) {\n        if (!mutations || !mutations.length)\n            return [];\n\n        var projection = new MutationProjection(this.root, mutations, this.elementFilter, this.calcReordered, this.options.oldPreviousSibling);\n\n        var summaries = [];\n        for (var i = 0; i < this.options.queries.length; i++) {\n            summaries.push(new Summary(projection, this.options.queries[i]));\n        }\n\n        return summaries;\n    };\n\n    MutationSummary.prototype.checkpointQueryValidators = function () {\n        this.queryValidators.forEach(function (validator) {\n            if (validator)\n                validator.recordPreviousState();\n        });\n    };\n\n    MutationSummary.prototype.runQueryValidators = function (summaries) {\n        this.queryValidators.forEach(function (validator, index) {\n            if (validator)\n                validator.validate(summaries[index]);\n        });\n    };\n\n    MutationSummary.prototype.changesToReport = function (summaries) {\n        return summaries.some(function (summary) {\n            var summaryProps = [\n                'added', 'removed', 'reordered', 'reparented',\n                'valueChanged', 'characterDataChanged'];\n            if (summaryProps.some(function (prop) {\n                return summary[prop] && summary[prop].length;\n            }))\n                return true;\n\n            if (summary.attributeChanged) {\n                var attrNames = Object.keys(summary.attributeChanged);\n                var attrsChanged = attrNames.some(function (attrName) {\n                    return !!summary.attributeChanged[attrName].length;\n                });\n                if (attrsChanged)\n                    return true;\n            }\n            return false;\n        });\n    };\n\n    MutationSummary.prototype.observerCallback = function (mutations) {\n        if (!this.options.observeOwnChanges)\n            this.observer.disconnect();\n\n        var summaries = this.createSummaries(mutations);\n        this.runQueryValidators(summaries);\n\n        if (this.options.observeOwnChanges)\n            this.checkpointQueryValidators();\n\n        if (this.changesToReport(summaries))\n            this.callback(summaries);\n\n        // disconnect() may have been called during the callback.\n        if (!this.options.observeOwnChanges && this.connected) {\n            this.checkpointQueryValidators();\n            this.observer.observe(this.root, this.observerOptions);\n        }\n    };\n\n    MutationSummary.prototype.reconnect = function () {\n        if (this.connected)\n            throw Error('Already connected');\n\n        this.observer.observe(this.root, this.observerOptions);\n        this.connected = true;\n        this.checkpointQueryValidators();\n    };\n\n    MutationSummary.prototype.takeSummaries = function () {\n        if (!this.connected)\n            throw Error('Not connected');\n\n        var summaries = this.createSummaries(this.observer.takeRecords());\n        return this.changesToReport(summaries) ? summaries : undefined;\n    };\n\n    MutationSummary.prototype.disconnect = function () {\n        var summaries = this.takeSummaries();\n        this.observer.disconnect();\n        this.connected = false;\n        return summaries;\n    };\n    MutationSummary.NodeMap = NodeMap;\n    MutationSummary.NodeIdMap = NodeIdMap;\n    MutationSummary.parseElementFilter = Selector.parseSelectors;\n\n    MutationSummary.optionKeys = {\n        'callback': true,\n        'queries': true,\n        'rootNode': true,\n        'oldPreviousSibling': true,\n        'observeOwnChanges': true\n    };\n    return MutationSummary;\n})();\n\n","///<reference path='../src/mutation-summary.ts'/>\n\nvar TreeMirror = (function () {\n    function TreeMirror(root, delegate) {\n        this.root = root;\n        this.delegate = delegate;\n        this.idMap = {};\n    }\n    TreeMirror.prototype.initialize = function (rootId, children, baseURI) {\n        this.baseURI = baseURI;\n        this.idMap[rootId] = this.root;\n\n        for (var i = 0; i < children.length; i++)\n            this.deserializeNode(children[i], this.root);\n    };\n\n    TreeMirror.prototype.applyChanged = function (removed, addedOrMoved, attributes, text) {\n        var _this = this;\n        // NOTE: Applying the changes can result in an attempting to add a child\n        // to a parent which is presently an ancestor of the parent. This can occur\n        // based on random ordering of moves. The way we handle this is to first\n        // remove all changed nodes from their parents, then apply.\n        addedOrMoved.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            var parent = _this.deserializeNode(data.parentNode);\n            var previous = _this.deserializeNode(data.previousSibling);\n            if (node.parentNode)\n                node.parentNode.removeChild(node);\n        });\n\n        removed.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            if (node.parentNode)\n                node.parentNode.removeChild(node);\n        });\n\n        addedOrMoved.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            var parent = _this.deserializeNode(data.parentNode);\n            var previous = _this.deserializeNode(data.previousSibling);\n            parent.insertBefore(node, previous ? previous.nextSibling : parent.firstChild);\n        });\n\n        attributes.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            Object.keys(data.attributes).forEach(function (attrName) {\n                var newVal = data.attributes[attrName];\n                if (newVal === null) {\n                    node.removeAttribute(attrName);\n                } else {\n                    if (!_this.delegate || !_this.delegate.setAttribute || !_this.delegate.setAttribute(node, attrName, newVal)) {\n                        node.setAttribute(attrName, newVal);\n                    }\n                }\n            });\n        });\n\n        text.forEach(function (data) {\n            var node = _this.deserializeNode(data);\n            node.textContent = data.textContent;\n        });\n\n        removed.forEach(function (node) {\n            delete _this.idMap[node.id];\n        });\n    };\n\n    TreeMirror.prototype.deserializeNode = function (nodeData, parent) {\n        var _this = this;\n        if (nodeData === null)\n            return null;\n\n        var node = this.idMap[nodeData.id];\n        if (node)\n            return node;\n\n        var doc = this.root.ownerDocument;\n        if (doc === null)\n            doc = this.root;\n\n        switch (nodeData.nodeType) {\n            case Node.COMMENT_NODE:\n                node = doc.createComment(nodeData.textContent);\n                break;\n\n            case Node.TEXT_NODE:\n                node = doc.createTextNode(nodeData.textContent);\n                break;\n\n            case Node.DOCUMENT_TYPE_NODE:\n                try {\n                    node = doc.implementation.createDocumentType(nodeData.name, nodeData.publicId, nodeData.systemId);\n                } catch (e) {\n                    // Ignore error from incorrect document type\n                }\n                break;\n\n            case Node.ELEMENT_NODE:\n                if (this.delegate && this.delegate.createElement)\n                    node = this.delegate.createElement(nodeData.tagName);\n                if (!node)\n                    node = doc.createElement(nodeData.tagName);\n                node.setAttribute('data-tagid', nodeData.id);\n\n                Object.keys(nodeData.attributes).forEach(function (name) {\n                    if (!_this.delegate || !_this.delegate.setAttribute || !_this.delegate.setAttribute(node, name, nodeData.attributes[name])) {\n                        node.setAttribute(name, nodeData.attributes[name]);\n                    }\n                });\n\n                break;\n        }\n\n        if (!node) {\n            throw new Error(\"No node with that id.\");\n        }\n\n        this.idMap[nodeData.id] = node;\n        node.nodeid = nodeData.id;\n\n        if (parent)\n            parent.appendChild(node);\n\n        if (nodeData.childNodes) {\n            for (var i = 0; i < nodeData.childNodes.length; i++)\n                this.deserializeNode(nodeData.childNodes[i], node);\n        }\n\n        return node;\n    };\n    return TreeMirror;\n})();\n\nvar URL_ATTRIBUTES = {\n    img_src: true,\n    link_href: true,\n    input_src: true,\n    body_background: true,\n    table_background: true,\n    td_background: true,\n    tr_background: true,\n    th_background: true,\n    tbody_background: true,\n    thead_background: true,\n    tfoot_background: true,\n    col_background: true,\n    colgroup_background: true,\n    section_background: true,\n    head_profile: true,\n    html_manifest: true,\n    command_icon: true,\n    embed_src: true,\n    object_data: true,\n    video_poster: true,\n    form_action: true,\n    iframe_src: true\n};\nfunction isUrlAttribute(tagName, attribute) {\n    var key = tagName.toLowerCase() + '_' + attribute.toLowerCase();\n    return URL_ATTRIBUTES[key] || false;\n}\n\nvar TreeMirrorClient = (function () {\n    function TreeMirrorClient(target, mirror, testingQueries) {\n        var _this = this;\n        this.target = target;\n        this.mirror = mirror;\n        this.nextId = 1;\n        this.knownNodes = new MutationSummary.NodeIdMap();\n        //this.knownNodes = new MutationSummary.NodeMap();\n\n        var rootId = this.serializeNode(target).id;\n        var children = [];\n        for (var child = target.firstChild; child; child = child.nextSibling)\n            children.push(this.serializeNode(child, true));\n\n        this.mirror.initialize(rootId, children, target.baseURI);\n\n        var self = this;\n\n        var queries = [{ all: true }];\n\n        if (testingQueries)\n            queries = queries.concat(testingQueries);\n\n        this.mutationSummary = new MutationSummary({\n            rootNode: target,\n            callback: function (summaries) {\n                try {\n                    _this.applyChanged(summaries);\n                } catch (e) {\n                    if (e.message !== 'No node with that id') {\n                        throw e;\n                    }\n                }\n            },\n            queries: queries\n        });\n    }\n    TreeMirrorClient.prototype.disconnect = function () {\n        if (this.mutationSummary) {\n            this.mutationSummary.disconnect();\n            this.mutationSummary = undefined;\n        }\n    };\n\n    TreeMirrorClient.prototype.rememberNode = function (node) {\n        var id = this.nextId++;\n        this.knownNodes.set(node, id);\n        return id;\n    };\n\n    TreeMirrorClient.prototype.forgetNode = function (node) {\n        this.knownNodes.delete(node);\n    };\n\n    TreeMirrorClient.prototype.serializeAttribute = function (node, attr, obj) {\n        var value = node.getAttribute(attr);\n        var tagName = node.tagName;\n\n        if(value === null) {\n            obj[attr] = null; // Attribute was removed\n            obj['data-portia-' + attr] = null;\n        } else if(attr === \"style\"){\n            obj[attr] = __portiaApi.processCss(value, node.baseURI);\n            obj['data-portia-' + attr] = value;\n        } else if (attr === 'srcset' && tagName === 'IMG') {\n            var split_attr = value.split(',')\n            for (var i=0; i < split_attr.length; i++) {\n                split_attr[i] = __portiaApi.wrapUrl(\n                    split_attr[i].trim(),\n                    node.baseURI);\n            }\n            obj[attr] = split_attr.join(', ')\n            obj['data-portia-' + attr] = value;\n        } else if (isUrlAttribute(tagName, attr)){\n            obj[attr] = __portiaApi.wrapUrl(value, node.baseURI);\n            obj['data-portia-' + attr] = value;\n        } else if (tagName === 'A' && attr === 'href') {\n            value = node.href;\n            if(!value || /^\\s*javascript:/i.test(value)){\n                obj[attr] = 'javascript:void(0)';\n                obj['data-portia-' + attr] = value;\n            } else {\n                obj[attr] = value;\n            }\n        } else {\n            obj[attr] = value;\n        }\n    };\n\n    TreeMirrorClient.prototype.serializeNode = function (node, recursive) {\n        if (node === null)\n            return null;\n\n        var id = this.knownNodes.get(node);\n        if (id !== undefined) {\n            return { id: id };\n        }\n\n        var data = {\n            nodeType: node.nodeType,\n            id: this.rememberNode(node)\n        };\n\n\n        switch (data.nodeType) {\n            case Node.DOCUMENT_TYPE_NODE:\n                var docType = node;\n                data.name = docType.name;\n                data.publicId = docType.publicId;\n                data.systemId = docType.systemId;\n                break;\n\n            case Node.COMMENT_NODE:\n            case Node.TEXT_NODE:\n                data.textContent = node.textContent;\n                if(node.parentNode && node.parentNode.tagName == \"STYLE\"){\n                    data.textContent = __portiaApi.processCss(data.textContent, node.baseURI);\n                }\n                break;\n\n            case Node.ELEMENT_NODE:\n                var elm = node;\n                data.tagName = elm.tagName;\n                data.attributes = {};\n                for (var i = 0; i < elm.attributes.length; i++) {\n                    var attr = elm.attributes[i];\n                    this.serializeAttribute(node, attr.name, data.attributes);\n                }\n\n                if (recursive && elm.childNodes.length) {\n                    data.childNodes = [];\n\n                    for (var child = elm.firstChild; child; child = child.nextSibling)\n                        data.childNodes.push(this.serializeNode(child, true));\n                }\n                break;\n        }\n\n        return data;\n    };\n\n    TreeMirrorClient.prototype.serializeAddedAndMoved = function (added, reparented, reordered) {\n        var _this = this;\n        var all = added.concat(reparented).concat(reordered);\n\n        var parentMap = new MutationSummary.NodeMap();\n\n        all.forEach(function (node) {\n            var parent = node.parentNode;\n            var children = parentMap.get(parent);\n            if (!children) {\n                children = new MutationSummary.NodeMap();\n                parentMap.set(parent, children);\n            }\n\n            children.set(node, true);\n        });\n\n        var moved = [];\n\n        parentMap.keys().forEach(function (parent) {\n            var children = parentMap.get(parent);\n\n            var keys = children.keys();\n            while (keys.length) {\n                var node = keys[0];\n                while (node.previousSibling && children.has(node.previousSibling))\n                    node = node.previousSibling;\n\n                while (node && children.has(node)) {\n                    var data = _this.serializeNode(node);\n                    data.previousSibling = _this.serializeNode(node.previousSibling);\n                    data.parentNode = _this.serializeNode(node.parentNode);\n                    moved.push(data);\n                    children.delete(node);\n                    node = node.nextSibling;\n                }\n\n                var keys = children.keys();\n            }\n        });\n\n        return moved;\n    };\n\n    TreeMirrorClient.prototype.serializeAttributeChanges = function (attributeChanged) {\n        var _this = this;\n        var map = new MutationSummary.NodeMap();\n\n        Object.keys(attributeChanged).forEach(function (attrName) {\n            (attributeChanged[attrName] || []).forEach(function (element) {\n                var record = map.get(element);\n                if (!record) {\n                    record = _this.serializeNode(element);\n                    record.attributes = {};\n                    map.set(element, record);\n                }\n\n                _this.serializeAttribute(element, attrName, record.attributes);\n            });\n        });\n\n        return map.keys().map(function (node) {\n            return map.get(node);\n        });\n    };\n\n    TreeMirrorClient.prototype.applyChanged = function (summaries) {\n        var _this = this;\n        var summary = summaries[0];\n\n        var removed = summary.removed.map(function (node) {\n            return _this.serializeNode(node);\n        });\n\n        var moved = this.serializeAddedAndMoved(summary.added, summary.reparented, summary.reordered);\n\n        var attributes = this.serializeAttributeChanges(summary.attributeChanged);\n\n        var text = summary.characterDataChanged.map(function (node) {\n            var data = _this.serializeNode(node);\n            data.textContent = node.textContent;\n            return data;\n        });\n\n        this.mirror.applyChanged(removed, moved, attributes, text);\n\n        summary.removed.forEach(function (node) {\n            _this.forgetNode(node);\n        });\n    };\n    return TreeMirrorClient;\n})();\n","// Keep a reference to some native methods, so we use the originals if\n// they are overridden by the page\nvar Json = JSON;\nvar JSONstringify = JSON.stringify;\nvar arraySplice = Array.prototype.splice;\nvar ArrayProto = Array.prototype;\nvar ObjectProto = Object.prototype;\nvar NumberProto = Number.prototype;\nvar StringProto = String.prototype;\nvar BooleanProto = Boolean.prototype;\n\n\n// Note: Variables here are not leaked to the global scope because the compiler wraps it in a function\n\nvar MAX_DIALOGS = 15;  // Maximum number of dialogs (alert, confirm, prompt) before throwing an exception\n\nvar PortiaPage = function PortiaPage() {\n    var that = this;\n    this.mirrorClient = new TreeMirrorClient(document, {\n        initialize: function(rootId, children, baseURI){\n            that.sendMessage('mutation', ['initialize', rootId, children, baseURI]);\n        },\n        applyChanged: function(removed, addedOrMoved, attributes, text){\n            that.sendMessage('mutation', ['applyChanged', removed, addedOrMoved, attributes, text]);\n        }\n    });\n};\n\nPortiaPage.prototype.sendMutation = function(){\n    this.sendMessage('mutation', arraySplice.call(arguments, 0));\n};\n\nPortiaPage.prototype.sendMessage = function(action, message) {\n    var oldAPtoJson = ArrayProto.toJSON;\n    var oldOPtoJson = ObjectProto.toJSON;\n    var oldNPtoJson = NumberProto.toJSON;\n    var oldSPtoJson = StringProto.toJSON;\n    var oldBPtoJson = BooleanProto.toJSON;\n    delete ArrayProto.toJSON;\n    delete ObjectProto.toJSON;\n    delete NumberProto.toJSON;\n    delete StringProto.toJSON;\n    delete BooleanProto.toJSON;\n\n    __portiaApi.sendMessage(JSONstringify.call(Json, [action, message]));\n\n    if(oldAPtoJson) { ArrayProto.toJSON   = oldAPtoJson; }\n    if(oldOPtoJson) { ObjectProto.toJSON  = oldOPtoJson; }\n    if(oldNPtoJson) { NumberProto.toJSON  = oldNPtoJson; }\n    if(oldSPtoJson) { StringProto.toJSON  = oldSPtoJson; }\n    if(oldBPtoJson) { BooleanProto.toJSON = oldBPtoJson; }\n};\n\nPortiaPage.prototype.url = function() {\n    return window.location;\n};\n\nPortiaPage.prototype.scrollX = function() {\n    return window.scrollX;\n};\n\nPortiaPage.prototype.scrollY = function() {\n    return window.scrollY;\n};\n\nPortiaPage.prototype.screenX = function() {\n    return window.screenX;\n};\n\nPortiaPage.prototype.screenY = function() {\n    return window.screenY;\n};\n\nPortiaPage.prototype.currentState = function() {\n    return {\n        url: this.url,\n        scroll: {\n            x: this.scrollX(),\n            y: this.scrollY(),\n            v: this.screenX(),\n            h: this.screenY(),\n            mx: window.scrollMaxX,\n            my: window.scrollMaxY\n        }\n    };\n};\n\nPortiaPage.sendEvent = {};\n\nPortiaPage.sendEvent.keyboard = function(element, data, type){\n    var ev = document.createEvent(\"KeyboardEvent\");\n    ev.initKeyboardEvent(type, true, true, window, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.keyCode, data.charCode);\n    element.dispatchEvent(ev);\n};\n\nPortiaPage.sendEvent.simple = function(element, data, type) {\n    var ev = document.createEvent('Event');\n    ev.initEvent(type, true, false);\n    element.dispatchEvent(ev);\n};\n\nPortiaPage.sendEvent.focus = function(element, data, type) {\n    if(type in element){\n        element[type](); // This will trigger the event\n    }\n};\n\nPortiaPage.sendEvent.scroll = function(element, data){\n    // Scroll events in the body are dispatched on the documentElement, reverse this\n    if(element === document.documentElement && element.scrollHeight === document.body.scrollHeight){\n        element = document.body;\n    }\n    // This will trigger the scroll event\n    element.scrollTop = data.scrollTop;\n    element.scrollLeft = data.scrollLeft;\n};\n\nPortiaPage.sendEvent.unknown = function(element, data, type) {\n    console.log('Unknown event category for event ' + type);\n};\n\nPortiaPage.sendEvent.mouse = function(element, data, type) {\n    var clientRect = element.getBoundingClientRect();\n    var clientX = data.targetX + clientRect.left;\n    var clientY = data.targetY + clientRect.top;\n\n    var ev = document.createEvent(\"MouseEvent\");\n    ev.initMouseEvent(type, true, true, window, data.detail || 0,\n                      clientX, clientY, clientX, clientY,\n                      data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.button, null);\n    element.dispatchEvent(ev);\n};\n\nPortiaPage.prototype.sendEvent = function(data) {\n    var element = this.getByNodeId(data.target);\n    if (!element) {\n        throw new Error(\"Event target doesn't exist.\");\n    }\n    Object.keys(data.propsBefore || {}).forEach(function(propName){\n        element[propName] = data.propsBefore[propName];\n    });\n\n    PortiaPage.sendEvent[data.category].call(this, element, data, data.type);\n\n    Object.keys(data.propsAfter || {}).forEach(function(propName){\n        element[propName] = data.propsAfter[propName];\n    });\n};\n\nPortiaPage.prototype.getByNodeId = function(nodeId){\n    return this.mirrorClient.knownNodes.byId[nodeId];\n};\n\nPortiaPage.prototype.pyGetByNodeId = function(nodeId){\n    // Workarround to return QWebElement in python\n    var res = this.getByNodeId(nodeId);\n    if(res) {\n        __portiaApi.returnElement(res);\n    }\n};\n\nvar incrementDialogCounter = function(){\n    if(++incrementDialogCounter.count > MAX_DIALOGS) {\n        throw new Error('Not allowed');\n    }\n};\nincrementDialogCounter.count = 0;\n\nwindow.alert = function(){};\n\nwindow.prompt = function(){\n    incrementDialogCounter();\n    return null; // dismiss the prompt (clicking cancel or closing the window)\n};\nwindow.confirm = function(){\n    incrementDialogCounter();\n    return true;\n};\n\nif(!('livePortiaPage' in window)){\n    window.livePortiaPage = new PortiaPage();\n}"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;","file":"combined.js"}